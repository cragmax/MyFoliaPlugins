import nl.vv32.rcon.Rcon
import java.io.File
import java.net.Socket

object ServerUtils {

    private const val POLL_INTERVAL_MS = 3000L
    private const val MAX_WAIT_MS = 60000L

    private fun isServerRunning(mcHost: String, mcPort: Int): Boolean {
        return try {
            Socket(mcHost, mcPort).use { true }
        } catch (_: Exception) {
            false
        }
    }

    fun stopServer(props: DeployProperties) {
        if (!isServerRunning(props.effectiveMcHost, props.mcPort)) {
            println("[deploy] Server is not running. Skipping stop.")
            return
        }

        try {
            println("[deploy] Connecting to RCON on ${props.effectiveRconHost}:${props.rconPort}...")
            val rcon = Rcon.open(props.effectiveRconHost, props.rconPort)

            if (!rcon.authenticate(props.rconPassword)) {
                println("[deploy] ERROR: RCON authentication failed. Check rconPassword in gradle.properties.")
                return
            }

            println("[deploy] Sending stop command...")
            rcon.sendCommand("stop")
            rcon.close()

        } catch (e: Exception) {
            // RCON can fail if the server is mid-startup or unresponsive
            // We still wait to see if the server stops on its own
            println("[deploy] WARNING: RCON failed: ${e.message}. Waiting to see if server stops anyway...")
        }

        println("[deploy] Waiting for server to stop...")
        val startTime = System.currentTimeMillis()

        while (true) {
            Thread.sleep(POLL_INTERVAL_MS)

            val elapsed = System.currentTimeMillis() - startTime

            if (!isServerRunning(props.effectiveMcHost, props.mcPort)) {
                println("[deploy] Server stopped after ${elapsed / 1000}s.")
                return
            }

            if (elapsed >= MAX_WAIT_MS) {
                println("[deploy] ERROR: Server did not stop within ${MAX_WAIT_MS / 1000}s. Aborting deploy.")
                return
            }

            println("[deploy] Still waiting... ${elapsed / 1000}s elapsed.")
        }
    }

    fun launchServerProcess(serverDir: String) {
        val dir = File(serverDir)
        val startBat = File(dir, "start.bat")

        if (!startBat.exists()) {
            error("[deploy] start.bat not found in $serverDir â€” should have been generated by copyStartBat")
        }

        println("[deploy] Starting server in new terminal window...")

        // cmd /k keeps the window open after the server stops so errors remain visible
        ProcessBuilder("cmd", "/c", "start", "cmd", "/k", startBat.absolutePath)
            .directory(dir)
            .start()

        println("[deploy] Server starting in new terminal window.")
    }

    fun launchServerProcessRemote(props: DeployProperties) {
        val sshUser = requireNotNull(props.serverSshUser) {
            "[deploy] serverSshUser is required when serverRemote=true"
        }
        val sshKeyPath = requireNotNull(props.serverSshKeyPath) {
            "[deploy] serverSshKeyPath is required when serverRemote=true"
        }

        println("[deploy] Starting server in new terminal window via SSH...")

        // Opens a terminal on the dev machine that SSHes into the server and runs start.bat
        // Output streams back to the dev terminal
        // Server process keeps running on the server machine if the terminal is closed
        val serverDirWin = props.remoteServerLocalDir.replace("/", "\\")

        ProcessBuilder(
            "cmd", "/c", "start", "cmd", "/k",
            "ssh", "-i", sshKeyPath.replace("/", "\\"),
            "$sshUser@${props.remoteMcHost}",
            "cmd /c \"$serverDirWin\\start.bat\""
        )
            .start()

        println("[deploy] Server launch command sent.")
    }
}